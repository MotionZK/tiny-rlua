/* automatically generated by rust-bindgen 0.65.1 */

pub const __GNUC_VA_LIST: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NEWLIB_MINOR__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.1.0\0";
pub const _NEWLIB__: u32 = 4;
pub const _PICOLIBC_MINOR__: u32 = 7;
pub const _PICOLIBC_VERSION: &[u8; 6usize] = b"1.7.4\0";
pub const _PICOLIBC__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const __PICOLIBC_PATCHLEVEL__: u32 = 4;
pub const __ATFILE_VISIBLE: u32 = 0;
pub const __BSD_VISIBLE: u32 = 0;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 1990;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 0;
pub const __POSIX_VISIBLE: u32 = 0;
pub const __SVID_VISIBLE: u32 = 0;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const ARG_MAX: u32 = 65536;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const CHAR_MIN: u32 = 0;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const LUA_PATH: &[u8; 9usize] = b"LUA_PATH\0";
pub const LUA_CPATH: &[u8; 10usize] = b"LUA_CPATH\0";
pub const LUA_INIT: &[u8; 9usize] = b"LUA_INIT\0";
pub const LUA_ROOT: &[u8; 12usize] = b"/usr/local/\0";
pub const LUA_LDIR: &[u8; 26usize] = b"/usr/local/share/lua/5.1/\0";
pub const LUA_CDIR: &[u8; 24usize] = b"/usr/local/lib/lua/5.1/\0";
pub const LUA_PATH_DEFAULT : & [u8 ; 138usize] = b"./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua\0" ;
pub const LUA_CPATH_DEFAULT: &[u8; 69usize] =
    b"./?.so;/usr/local/lib/lua/5.1/?.so;/usr/local/lib/lua/5.1/loadall.so\0";
pub const LUA_DIRSEP: &[u8; 2usize] = b"/\0";
pub const LUA_PATHSEP: &[u8; 2usize] = b";\0";
pub const LUA_PATH_MARK: &[u8; 2usize] = b"?\0";
pub const LUA_EXECDIR: &[u8; 2usize] = b"!\0";
pub const LUA_IGMARK: &[u8; 2usize] = b"-\0";
pub const LUA_IDSIZE: u32 = 60;
pub const LUAI_GCPAUSE: u32 = 200;
pub const LUAI_GCMUL: u32 = 200;
pub const LUA_COMPAT_LSTR: u32 = 1;
pub const LUAI_BITSINT: u32 = 32;
pub const LUAI_MAXCALLS: u32 = 20000;
pub const LUAI_MAXCSTACK: u32 = 8000;
pub const LUAI_MAXCCALLS: u32 = 200;
pub const LUAI_MAXVARS: u32 = 200;
pub const LUAI_MAXUPVALUES: u32 = 60;
pub const LUA_NUMBER_SCAN: &[u8; 4usize] = b"%lf\0";
pub const LUA_NUMBER_FMT: &[u8; 6usize] = b"%.14g\0";
pub const LUAI_MAXNUMBER2STR: u32 = 32;
pub const LUA_MAXCAPTURES: u32 = 32;
pub const LUAI_EXTRASPACE: u32 = 0;
pub const LUA_INTFRMLEN: &[u8; 2usize] = b"l\0";
pub const LUA_VERSION: &[u8; 8usize] = b"Lua 5.1\0";
pub const LUA_RELEASE: &[u8; 10usize] = b"Lua 5.1.5\0";
pub const LUA_VERSION_NUM: u32 = 501;
pub const LUA_COPYRIGHT: &[u8; 41usize] = b"Copyright (C) 1994-2012 Lua.org, PUC-Rio\0";
pub const LUA_AUTHORS: &[u8; 49usize] = b"R. Ierusalimschy, L. H. de Figueiredo & W. Celes\0";
pub const LUA_SIGNATURE: &[u8; 5usize] = b"\x1BLua\0";
pub const LUA_MULTRET: i32 = -1;
pub const LUA_REGISTRYINDEX: i32 = -10000;
pub const LUA_ENVIRONINDEX: i32 = -10001;
pub const LUA_GLOBALSINDEX: i32 = -10002;
pub const LUA_YIELD: u32 = 1;
pub const LUA_ERRRUN: u32 = 2;
pub const LUA_ERRSYNTAX: u32 = 3;
pub const LUA_ERRMEM: u32 = 4;
pub const LUA_ERRERR: u32 = 5;
pub const LUA_TNONE: i32 = -1;
pub const LUA_TNIL: u32 = 0;
pub const LUA_TBOOLEAN: u32 = 1;
pub const LUA_TLIGHTUSERDATA: u32 = 2;
pub const LUA_TNUMBER: u32 = 3;
pub const LUA_TSTRING: u32 = 4;
pub const LUA_TTABLE: u32 = 5;
pub const LUA_TFUNCTION: u32 = 6;
pub const LUA_TUSERDATA: u32 = 7;
pub const LUA_TTHREAD: u32 = 8;
pub const LUA_MINSTACK: u32 = 20;
pub const LUA_GCSTOP: u32 = 0;
pub const LUA_GCRESTART: u32 = 1;
pub const LUA_GCCOLLECT: u32 = 2;
pub const LUA_GCCOUNT: u32 = 3;
pub const LUA_GCCOUNTB: u32 = 4;
pub const LUA_GCSTEP: u32 = 5;
pub const LUA_GCSETPAUSE: u32 = 6;
pub const LUA_GCSETSTEPMUL: u32 = 7;
pub const LUA_HOOKCALL: u32 = 0;
pub const LUA_HOOKRET: u32 = 1;
pub const LUA_HOOKLINE: u32 = 2;
pub const LUA_HOOKCOUNT: u32 = 3;
pub const LUA_HOOKTAILRET: u32 = 4;
pub const LUA_MASKCALL: u32 = 1;
pub const LUA_MASKRET: u32 = 2;
pub const LUA_MASKLINE: u32 = 4;
pub const LUA_MASKCOUNT: u32 = 8;
pub const LUA_FILEHANDLE: &[u8; 6usize] = b"FILE*\0";
pub const LUA_COLIBNAME: &[u8; 10usize] = b"coroutine\0";
pub const LUA_TABLIBNAME: &[u8; 6usize] = b"table\0";
pub const LUA_IOLIBNAME: &[u8; 3usize] = b"io\0";
pub const LUA_OSLIBNAME: &[u8; 3usize] = b"os\0";
pub const LUA_STRLIBNAME: &[u8; 7usize] = b"string\0";
pub const LUA_MATHLIBNAME: &[u8; 5usize] = b"math\0";
pub const LUA_DBLIBNAME: &[u8; 6usize] = b"debug\0";
pub const LUA_LOADLIBNAME: &[u8; 8usize] = b"package\0";
pub const _STDIO_H_: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT_FLOAT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT_DOUBLE: u32 = 0;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __OBSOLETE_MATH_FLOAT: u32 = 1;
pub const __OBSOLETE_MATH_DOUBLE: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __PICOLIBC_UNGETC_SIZE: u32 = 4;
pub const __SRD: u32 = 1;
pub const __SWR: u32 = 2;
pub const __SERR: u32 = 4;
pub const __SEOF: u32 = 8;
pub const __SCLOSE: u32 = 16;
pub const EOF: i32 = -1;
pub const _FDEV_SETUP_READ: u32 = 1;
pub const _FDEV_SETUP_WRITE: u32 = 2;
pub const _FDEV_SETUP_RW: u32 = 3;
pub const _FDEV_ERR: i32 = -1;
pub const _FDEV_EOF: i32 = -2;
pub const BUFSIZ: u32 = 512;
pub const _IONBF: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const LUA_ERRFILE: u32 = 6;
pub const LUA_NOREF: i32 = -2;
pub const LUA_REFNIL: i32 = -1;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::core::ffi::c_int;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_State {
    _unused: [u8; 0],
}
pub type lua_CFunction =
    ::core::option::Option<unsafe extern "C" fn(L: *mut lua_State) -> ::core::ffi::c_int>;
pub type lua_Reader = ::core::option::Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        ud: *mut ::core::ffi::c_void,
        sz: *mut usize,
    ) -> *const ::core::ffi::c_char,
>;
pub type lua_Writer = ::core::option::Option<
    unsafe extern "C" fn(
        L: *mut lua_State,
        p: *const ::core::ffi::c_void,
        sz: usize,
        ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type lua_Alloc = ::core::option::Option<
    unsafe extern "C" fn(
        ud: *mut ::core::ffi::c_void,
        ptr: *mut ::core::ffi::c_void,
        osize: usize,
        nsize: usize,
    ) -> *mut ::core::ffi::c_void,
>;
pub type lua_Number = f64;
pub type lua_Integer = isize;
extern "C" {
    pub fn lua_newstate(f: lua_Alloc, ud: *mut ::core::ffi::c_void) -> *mut lua_State;
}
extern "C" {
    pub fn lua_close(L: *mut lua_State);
}
extern "C" {
    pub fn lua_newthread(L: *mut lua_State) -> *mut lua_State;
}
extern "C" {
    pub fn lua_atpanic(L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction;
}
extern "C" {
    pub fn lua_gettop(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_settop(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_pushvalue(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_remove(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_insert(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_replace(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_checkstack(L: *mut lua_State, sz: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_xmove(from: *mut lua_State, to: *mut lua_State, n: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_isnumber(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_isstring(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_iscfunction(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_isuserdata(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_type(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_typename(L: *mut lua_State, tp: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_equal(
        L: *mut lua_State,
        idx1: ::core::ffi::c_int,
        idx2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_rawequal(
        L: *mut lua_State,
        idx1: ::core::ffi::c_int,
        idx2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_lessthan(
        L: *mut lua_State,
        idx1: ::core::ffi::c_int,
        idx2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_tonumber(L: *mut lua_State, idx: ::core::ffi::c_int) -> lua_Number;
}
extern "C" {
    pub fn lua_tointeger(L: *mut lua_State, idx: ::core::ffi::c_int) -> lua_Integer;
}
extern "C" {
    pub fn lua_toboolean(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_tolstring(
        L: *mut lua_State,
        idx: ::core::ffi::c_int,
        len: *mut usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_objlen(L: *mut lua_State, idx: ::core::ffi::c_int) -> usize;
}
extern "C" {
    pub fn lua_tocfunction(L: *mut lua_State, idx: ::core::ffi::c_int) -> lua_CFunction;
}
extern "C" {
    pub fn lua_touserdata(L: *mut lua_State, idx: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn lua_tothread(L: *mut lua_State, idx: ::core::ffi::c_int) -> *mut lua_State;
}
extern "C" {
    pub fn lua_topointer(L: *mut lua_State, idx: ::core::ffi::c_int) -> *const ::core::ffi::c_void;
}
extern "C" {
    pub fn lua_pushnil(L: *mut lua_State);
}
extern "C" {
    pub fn lua_pushnumber(L: *mut lua_State, n: lua_Number);
}
extern "C" {
    pub fn lua_pushinteger(L: *mut lua_State, n: lua_Integer);
}
extern "C" {
    pub fn lua_pushlstring(L: *mut lua_State, s: *const ::core::ffi::c_char, l: usize);
}
extern "C" {
    pub fn lua_pushstring(L: *mut lua_State, s: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn lua_pushvfstring(
        L: *mut lua_State,
        fmt: *const ::core::ffi::c_char,
        argp: va_list,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_pushfstring(
        L: *mut lua_State,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_pushcclosure(L: *mut lua_State, fn_: lua_CFunction, n: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_pushboolean(L: *mut lua_State, b: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_pushlightuserdata(L: *mut lua_State, p: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn lua_pushthread(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_gettable(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_getfield(L: *mut lua_State, idx: ::core::ffi::c_int, k: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn lua_rawget(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_rawgeti(L: *mut lua_State, idx: ::core::ffi::c_int, n: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_createtable(L: *mut lua_State, narr: ::core::ffi::c_int, nrec: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_newuserdata(L: *mut lua_State, sz: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn lua_getmetatable(L: *mut lua_State, objindex: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_getfenv(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_settable(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_setfield(L: *mut lua_State, idx: ::core::ffi::c_int, k: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn lua_rawset(L: *mut lua_State, idx: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_rawseti(L: *mut lua_State, idx: ::core::ffi::c_int, n: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_setmetatable(L: *mut lua_State, objindex: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_setfenv(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_call(L: *mut lua_State, nargs: ::core::ffi::c_int, nresults: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_pcall(
        L: *mut lua_State,
        nargs: ::core::ffi::c_int,
        nresults: ::core::ffi::c_int,
        errfunc: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_cpcall(
        L: *mut lua_State,
        func: lua_CFunction,
        ud: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_load(
        L: *mut lua_State,
        reader: lua_Reader,
        dt: *mut ::core::ffi::c_void,
        chunkname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_dump(
        L: *mut lua_State,
        writer: lua_Writer,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_yield(L: *mut lua_State, nresults: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_resume(L: *mut lua_State, narg: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_status(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_gc(
        L: *mut lua_State,
        what: ::core::ffi::c_int,
        data: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_error(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_next(L: *mut lua_State, idx: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_concat(L: *mut lua_State, n: ::core::ffi::c_int);
}
extern "C" {
    pub fn lua_getallocf(L: *mut lua_State, ud: *mut *mut ::core::ffi::c_void) -> lua_Alloc;
}
extern "C" {
    pub fn lua_setallocf(L: *mut lua_State, f: lua_Alloc, ud: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn lua_setlevel(from: *mut lua_State, to: *mut lua_State);
}
pub type lua_Hook =
    ::core::option::Option<unsafe extern "C" fn(L: *mut lua_State, ar: *mut lua_Debug)>;
extern "C" {
    pub fn lua_getstack(
        L: *mut lua_State,
        level: ::core::ffi::c_int,
        ar: *mut lua_Debug,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_getinfo(
        L: *mut lua_State,
        what: *const ::core::ffi::c_char,
        ar: *mut lua_Debug,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_getlocal(
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_setlocal(
        L: *mut lua_State,
        ar: *const lua_Debug,
        n: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_getupvalue(
        L: *mut lua_State,
        funcindex: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_setupvalue(
        L: *mut lua_State,
        funcindex: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn lua_sethook(
        L: *mut lua_State,
        func: lua_Hook,
        mask: ::core::ffi::c_int,
        count: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_gethook(L: *mut lua_State) -> lua_Hook;
}
extern "C" {
    pub fn lua_gethookmask(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lua_gethookcount(L: *mut lua_State) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_Debug {
    pub event: ::core::ffi::c_int,
    pub name: *const ::core::ffi::c_char,
    pub namewhat: *const ::core::ffi::c_char,
    pub what: *const ::core::ffi::c_char,
    pub source: *const ::core::ffi::c_char,
    pub currentline: ::core::ffi::c_int,
    pub nups: ::core::ffi::c_int,
    pub linedefined: ::core::ffi::c_int,
    pub lastlinedefined: ::core::ffi::c_int,
    pub short_src: [::core::ffi::c_char; 60usize],
    pub i_ci: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_lua_Debug() {
    const UNINIT: ::core::mem::MaybeUninit<lua_Debug> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lua_Debug>(),
        100usize,
        concat!("Size of: ", stringify!(lua_Debug))
    );
    assert_eq!(
        ::core::mem::align_of::<lua_Debug>(),
        4usize,
        concat!("Alignment of ", stringify!(lua_Debug))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).namewhat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(namewhat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).what) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(what)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currentline) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(currentline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nups) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(nups)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linedefined) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(linedefined)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastlinedefined) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(lastlinedefined)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).short_src) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(short_src)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i_ci) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lua_Debug),
            "::",
            stringify!(i_ci)
        )
    );
}
extern "C" {
    pub fn luaopen_base(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_table(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_io(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_os(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_string(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_math(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_debug(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaopen_package(L: *mut lua_State) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_openlibs(L: *mut lua_State);
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
}
pub type wint_t = ::core::ffi::c_uint;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __ungetc_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __file {
    pub unget: __ungetc_t,
    pub flags: u8,
    pub put: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::core::ffi::c_char, arg2: *mut __file) -> ::core::ffi::c_int,
    >,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> ::core::ffi::c_int>,
    pub flush:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> ::core::ffi::c_int>,
}
#[test]
fn bindgen_test_layout___file() {
    const UNINIT: ::core::mem::MaybeUninit<__file> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__file>(),
        20usize,
        concat!("Size of: ", stringify!(__file))
    );
    assert_eq!(
        ::core::mem::align_of::<__file>(),
        4usize,
        concat!("Alignment of ", stringify!(__file))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unget) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__file),
            "::",
            stringify!(unget)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__file),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).put) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__file),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__file),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__file),
            "::",
            stringify!(flush)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __file_close {
    pub file: __file,
    pub close:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> ::core::ffi::c_int>,
}
#[test]
fn bindgen_test_layout___file_close() {
    const UNINIT: ::core::mem::MaybeUninit<__file_close> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__file_close>(),
        24usize,
        concat!("Size of: ", stringify!(__file_close))
    );
    assert_eq!(
        ::core::mem::align_of::<__file_close>(),
        4usize,
        concat!("Alignment of ", stringify!(__file_close))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__file_close),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__file_close),
            "::",
            stringify!(close)
        )
    );
}
#[doc = "\\c FILE is the opaque structure that is passed around between the\nvarious standard IO functions."]
pub type __FILE = __file;
pub type FILE = __FILE;
extern "C" {
    #[doc = "Stream that will be used as an input stream by the simplified\nfunctions that don't take a \\c stream argument."]
    pub static stdin: *mut FILE;
}
extern "C" {
    #[doc = "Stream that will be used as an output stream by the simplified\nfunctions that don't take a \\c stream argument."]
    pub static stdout: *mut FILE;
}
extern "C" {
    #[doc = "Stream destined for error output.  Unless specifically assigned,\nidentical to \\c stdout."]
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fdevopen(
        __put: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int,
        >,
        __get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut FILE) -> ::core::ffi::c_int>,
        __flush: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut FILE) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = "This function closes \\c stream, and disallows and further\nIO to and from it.\n\nWhen using fdevopen() to setup the stream, a call to fclose() is\nneeded in order to free the internal resources allocated.\n\nIf the stream has been set up using fdev_setup_stream() or\nFDEV_SETUP_STREAM(), use fdev_close() instead.\n\nIt currently always returns 0 (for success)."]
    pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        __stream: *mut FILE,
        __fmt: *const ::core::ffi::c_char,
        __ap: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c fputc sends the character \\c c (though given as type\n\\c int) to \\c stream.  It returns the character, or \\c EOF in case\nan error occurred."]
    pub fn fputc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c printf performs formatted output to stream\n\\c stdout.  See \\c vfprintf() for details."]
    pub fn printf(__fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c vprintf performs formatted output to stream\n\\c stdout, taking a variable argument list as in vfprintf().\n\nSee vfprintf() for details."]
    pub fn vprintf(
        __fmt: *const ::core::ffi::c_char,
        __ap: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Variant of \\c printf() that sends the formatted characters\nto string \\c s."]
    pub fn sprintf(
        __s: *mut ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Like \\c sprintf(), but instead of assuming \\c s to be of infinite\nsize, no more than \\c n characters (including the trailing NUL\ncharacter) will be converted to \\c s.\n\nReturns the number of characters that would have been written to\n\\c s if there were enough space."]
    pub fn snprintf(
        __s: *mut ::core::ffi::c_char,
        __n: ::core::ffi::c_uint,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Like \\c sprintf() but takes a variable argument list for the\narguments."]
    pub fn vsprintf(
        __s: *mut ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ap: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Like \\c vsprintf(), but instead of assuming \\c s to be of infinite\nsize, no more than \\c n characters (including the trailing NUL\ncharacter) will be converted to \\c s.\n\nReturns the number of characters that would have been written to\n\\c s if there were enough space."]
    pub fn vsnprintf(
        __s: *mut ::core::ffi::c_char,
        __n: ::core::ffi::c_uint,
        __fmt: *const ::core::ffi::c_char,
        ap: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Variant of \\c printf() that sends the formatted characters\nto allocated string \\c *strp."]
    pub fn asprintf(
        strp: *mut *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Variant of \\c vprintf() that sends the formatted characters\nto allocated string \\c *strp."]
    pub fn vasprintf(
        strp: *mut *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ap: va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c fprintf performs formatted output to \\c stream.\nSee \\c vfprintf() for details."]
    pub fn fprintf(
        __stream: *mut FILE,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Write the string pointed to by \\c str to stream \\c stream.\n\nReturns 0 on success and EOF on error."]
    pub fn fputs(__str: *const ::core::ffi::c_char, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Write the string pointed to by \\c str, and a trailing newline\ncharacter, to \\c stdout."]
    pub fn puts(__str: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Write \\c nmemb objects, \\c size bytes each, to \\c stream.\nThe first byte of the first object is referenced by \\c ptr.\n\nReturns the number of objects successfully written, i. e.\n\\c nmemb unless an output error occured."]
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::core::ffi::c_uint,
        __nmemb: ::core::ffi::c_uint,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = "The function \\c fgetc reads a character from \\c stream.  It returns\nthe character, or \\c EOF in case end-of-file was encountered or an\nerror occurred.  The routines feof() or ferror() must be used to\ndistinguish between both situations."]
    pub fn fgetc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The ungetc() function pushes the character \\c c (converted to an\nunsigned char) back onto the input stream pointed to by \\c stream.\nThe pushed-back character will be returned by a subsequent read on\nthe stream.\n\nCurrently, only a single character can be pushed back onto the\nstream.\n\nThe ungetc() function returns the character pushed back after the\nconversion, or \\c EOF if the operation fails.  If the value of the\nargument \\c c character equals \\c EOF, the operation will fail and\nthe stream will remain unchanged."]
    pub fn ungetc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Read at most <tt>size - 1</tt> bytes from \\c stream, until a\nnewline character was encountered, and store the characters in the\nbuffer pointed to by \\c str.  Unless an error was encountered while\nreading, the string will then be terminated with a \\c NUL\ncharacter.\n\nIf an error was encountered, the function returns NULL and sets the\nerror flag of \\c stream, which can be tested using ferror().\nOtherwise, a pointer to the string will be returned."]
    pub fn fgets(
        __str: *mut ::core::ffi::c_char,
        __size: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "Similar to fgets() except that it will operate on stream \\c stdin,\nand the trailing newline (if any) will not be stored in the string.\nIt is the caller's responsibility to provide enough storage to hold\nthe characters read."]
    pub fn gets(__str: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = "Read \\c nmemb objects, \\c size bytes each, from \\c stream,\nto the buffer pointed to by \\c ptr.\n\nReturns the number of objects successfully read, i. e.\n\\c nmemb unless an input error occured or end-of-file was\nencountered.  feof() and ferror() must be used to distinguish\nbetween these two conditions."]
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_uint,
        __nmemb: ::core::ffi::c_uint,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = "Clear the error and end-of-file flags of \\c stream."]
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    #[doc = "Test the end-of-file flag of \\c stream.  This flag can only be cleared\nby a call to clearerr()."]
    pub fn feof(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Test the error flag of \\c stream.  This flag can only be cleared\nby a call to clearerr()."]
    pub fn ferror(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __fmt: *const ::core::ffi::c_char,
        __ap: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c fscanf performs formatted input, reading the\ninput data from \\c stream.\n\nSee vfscanf() for details."]
    pub fn fscanf(
        __stream: *mut FILE,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c scanf performs formatted input from stream \\c stdin.\n\nSee vfscanf() for details."]
    pub fn scanf(__fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c vscanf performs formatted input from stream\n\\c stdin, taking a variable argument list as in vfscanf().\n\nSee vfscanf() for details."]
    pub fn vscanf(__fmt: *const ::core::ffi::c_char, __ap: __builtin_va_list)
        -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c sscanf performs formatted input, reading the\ninput data from the buffer pointed to by \\c buf.\n\nSee vfscanf() for details."]
    pub fn sscanf(
        __buf: *const ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "The function \\c vscanf performs formatted input, reading the\ninput data from the buffer pointed to by \\c buf.\n\nSee vfscanf() for details."]
    pub fn vsscanf(
        __buf: *const ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ap: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = "Flush \\c stream.\n\nIf the stream provides a flush hook, use that. Otherwise return 0."]
    pub fn fflush(stream: *mut FILE) -> ::core::ffi::c_int;
}
pub type fpos_t = ::core::ffi::c_longlong;
extern "C" {
    pub fn fgetpos(stream: *mut FILE, pos: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fopen(path: *const ::core::ffi::c_char, mode: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fseek(
        stream: *mut FILE,
        offset: ::core::ffi::c_long,
        whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(stream: *mut FILE, pos: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(stream: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(s: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn remove(pathname: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        oldpath: *const ::core::ffi::c_char,
        newpath: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rewind(stream: *mut FILE);
}
extern "C" {
    pub fn setbuf(stream: *mut FILE, buf: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        stream: *mut FILE,
        buf: *mut ::core::ffi::c_char,
        mode: ::core::ffi::c_int,
        size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct luaL_Reg {
    pub name: *const ::core::ffi::c_char,
    pub func: lua_CFunction,
}
#[test]
fn bindgen_test_layout_luaL_Reg() {
    const UNINIT: ::core::mem::MaybeUninit<luaL_Reg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<luaL_Reg>(),
        8usize,
        concat!("Size of: ", stringify!(luaL_Reg))
    );
    assert_eq!(
        ::core::mem::align_of::<luaL_Reg>(),
        4usize,
        concat!("Alignment of ", stringify!(luaL_Reg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Reg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Reg),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    pub fn luaL_openlib(
        L: *mut lua_State,
        libname: *const ::core::ffi::c_char,
        l: *const luaL_Reg,
        nup: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn luaL_register(
        L: *mut lua_State,
        libname: *const ::core::ffi::c_char,
        l: *const luaL_Reg,
    );
}
extern "C" {
    pub fn luaL_getmetafield(
        L: *mut lua_State,
        obj: ::core::ffi::c_int,
        e: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_callmeta(
        L: *mut lua_State,
        obj: ::core::ffi::c_int,
        e: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_typerror(
        L: *mut lua_State,
        narg: ::core::ffi::c_int,
        tname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_argerror(
        L: *mut lua_State,
        numarg: ::core::ffi::c_int,
        extramsg: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_checklstring(
        L: *mut lua_State,
        numArg: ::core::ffi::c_int,
        l: *mut usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn luaL_optlstring(
        L: *mut lua_State,
        numArg: ::core::ffi::c_int,
        def: *const ::core::ffi::c_char,
        l: *mut usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn luaL_checknumber(L: *mut lua_State, numArg: ::core::ffi::c_int) -> lua_Number;
}
extern "C" {
    pub fn luaL_optnumber(
        L: *mut lua_State,
        nArg: ::core::ffi::c_int,
        def: lua_Number,
    ) -> lua_Number;
}
extern "C" {
    pub fn luaL_checkinteger(L: *mut lua_State, numArg: ::core::ffi::c_int) -> lua_Integer;
}
extern "C" {
    pub fn luaL_optinteger(
        L: *mut lua_State,
        nArg: ::core::ffi::c_int,
        def: lua_Integer,
    ) -> lua_Integer;
}
extern "C" {
    pub fn luaL_checkstack(
        L: *mut lua_State,
        sz: ::core::ffi::c_int,
        msg: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn luaL_checktype(L: *mut lua_State, narg: ::core::ffi::c_int, t: ::core::ffi::c_int);
}
extern "C" {
    pub fn luaL_checkany(L: *mut lua_State, narg: ::core::ffi::c_int);
}
extern "C" {
    pub fn luaL_newmetatable(
        L: *mut lua_State,
        tname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_checkudata(
        L: *mut lua_State,
        ud: ::core::ffi::c_int,
        tname: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn luaL_where(L: *mut lua_State, lvl: ::core::ffi::c_int);
}
extern "C" {
    pub fn luaL_error(
        L: *mut lua_State,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_checkoption(
        L: *mut lua_State,
        narg: ::core::ffi::c_int,
        def: *const ::core::ffi::c_char,
        lst: *const *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_ref(L: *mut lua_State, t: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_unref(L: *mut lua_State, t: ::core::ffi::c_int, ref_: ::core::ffi::c_int);
}
extern "C" {
    pub fn luaL_loadfile(
        L: *mut lua_State,
        filename: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_loadbuffer(
        L: *mut lua_State,
        buff: *const ::core::ffi::c_char,
        sz: usize,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_loadstring(L: *mut lua_State, s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn luaL_newstate() -> *mut lua_State;
}
extern "C" {
    pub fn luaL_gsub(
        L: *mut lua_State,
        s: *const ::core::ffi::c_char,
        p: *const ::core::ffi::c_char,
        r: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn luaL_findtable(
        L: *mut lua_State,
        idx: ::core::ffi::c_int,
        fname: *const ::core::ffi::c_char,
        szhint: ::core::ffi::c_int,
    ) -> *const ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct luaL_Buffer {
    pub p: *mut ::core::ffi::c_char,
    pub lvl: ::core::ffi::c_int,
    pub L: *mut lua_State,
    pub buffer: [::core::ffi::c_char; 512usize],
}
#[test]
fn bindgen_test_layout_luaL_Buffer() {
    const UNINIT: ::core::mem::MaybeUninit<luaL_Buffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<luaL_Buffer>(),
        524usize,
        concat!("Size of: ", stringify!(luaL_Buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<luaL_Buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(luaL_Buffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lvl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(lvl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).L) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(luaL_Buffer),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    pub fn luaL_buffinit(L: *mut lua_State, B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_prepbuffer(B: *mut luaL_Buffer) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn luaL_addlstring(B: *mut luaL_Buffer, s: *const ::core::ffi::c_char, l: usize);
}
extern "C" {
    pub fn luaL_addstring(B: *mut luaL_Buffer, s: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn luaL_addvalue(B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_pushresult(B: *mut luaL_Buffer);
}
pub type __builtin_va_list = *mut ::core::ffi::c_void;
